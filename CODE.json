[
    {
        "id": 1,
        "slip_no": "slip 1",
        "question": "Write the simulation program to implement demand paging and show the page scheduling and total number of page faults according to the LFU page replacement algorithm. Assume the memory of n frames. Reference String : 3,4,5,4,3,4,7,2,4,5,6,7,2,4,6.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n// Function to find the index of the least frequently used page\nint findLFU(int frames[], int freq[], int n) {\n    int min = INT_MAX, min_index = -1;\n    for (int i = 0; i < n; i++) {\n        if (freq[i] < min) {\n            min = freq[i];\n            min_index = i;\n        }\n    }\n    return min_index;\n}\n\n// Function to check if a page is present in the frames\nint isPresent(int frames[], int page, int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == page)\n            return i;\n    }\n    return -1;\n}\n\nint main() {\n    int n, num_pages;\n    int frames[MAX_FRAMES], freq[MAX_FRAMES], ref_str[MAX_PAGES];\n    int page_faults = 0;\n\n    // Initialize frames and frequency\n    for (int i = 0; i < MAX_FRAMES; i++) {\n        frames[i] = -1;\n        freq[i] = 0;\n    }\n\n    // Input: number of frames\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &n);\n\n    // Input: reference string\n    printf(\"Enter the number of pages in the reference string: \");\n    scanf(\"%d\", &num_pages);\n    printf(\"Enter reference string: \");\n    for (int i = 0; i < num_pages; i++) {\n        scanf(\"%d\", &ref_str[i]);\n    }\n\n    // Page scheduling and LFU algorithm\n    for (int i = 0; i < num_pages; i++) {\n        int page = ref_str[i];\n        int pos = isPresent(frames, page, n);\n\n        // Page is not present in memory, a page fault occurs\n        if (pos == -1) {\n            // Find a free frame or replace the least frequently used page\n            int replace_index = findLFU(frames, freq, n);\n\n            // Replace the page and update frequency\n            frames[replace_index] = page;\n            freq[replace_index] = 1; // Reset frequency for the new page\n            page_faults++;\n\n            // Display frames content\n            printf(\"Page %d caused a page fault. Frames: \", page);\n            for (int j = 0; j < n; j++) {\n                if (frames[j] != -1)\n                    printf(\"%d \", frames[j]);\n                else\n                    printf(\"- \");\n            }\n            printf(\"\\n\");\n        } else {\n            // Page is already in memory, just update its frequency\n            freq[pos]++;\n            printf(\"Page %d found in memory. No page fault.\\n\", page);\n        }\n    }\n\n    printf(\"\\nTotal page faults: %d\\n\", page_faults);\n    return 0;\n}"
    },
    {
        "id": 2,
        "slip_no": "slip 1",
        "question": "Write a C program to implement the shell which displays the command prompt 'myshell$'. It accepts the command, tokenize the command line and execute it by creating the child process. Also implement the additional command 'typeline' as typeline +n filename :- To print first n lines in the file. typeline -a filename :- To print all lines in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to handle the 'typeline' command\nvoid typeline(int argc, char **args) {\n    if (argc != 3) {\n        printf(\"Usage: typeline +n filename OR typeline -a filename\\n\");\n        return;\n    }\n\n    char *filename = args[2];\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    if (strcmp(args[1], \"-a\") == 0) {\n        // Print all lines\n        while (fgets(line, sizeof(line), file)) {\n            printf(\"%s\", line);\n        }\n    } else if (args[1][0] == '+' && atoi(args[1] + 1) > 0) {\n        // Print first n lines\n        int n = atoi(args[1] + 1);\n        while (fgets(line, sizeof(line), file) && count < n) {\n            printf(\"%s\", line);\n            count++;\n        }\n    } else {\n        printf(\"Invalid typeline command\\n\");\n    }\n\n    fclose(file);\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for 'exit' command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Handle the 'typeline' command\n        if (strcmp(args[0], \"typeline\") == 0) {\n            typeline(MAX_ARGS, args);\n            continue;\n        }\n\n        // Fork a child process to execute the command\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 3,
        "slip_no": "slip 2",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the FIFO page replacement algorithm. Assume the memory of n frames. Reference String: 3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6.",
        "language": "c",
        "code": "#include <stdio.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to check if a page is present in memory\nint isPageInMemory(int page, int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == page) {\n            return 1; // Page found in memory\n        }\n    }\n    return 0; // Page not found\n}\n\n// Function to print the current state of frames\nvoid printFrames(int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == -1) {\n            printf(\"- \");\n        } else {\n            printf(\"%d \", frames[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n; // Number of frames\n    int frames[MAX_FRAMES], reference_string[] = {3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};\n    int num_pages = sizeof(reference_string) / sizeof(reference_string[0]);\n    int page_faults = 0;\n    int current_frame = 0; // To keep track of the next frame to replace (FIFO)\n\n    // Input: number of frames\n    printf(\"Enter the number of frames: \");\n    scanf(\"%d\", &n);\n\n    // Initialize frames to -1 (indicating they are empty)\n    for (int i = 0; i < n; i++) {\n        frames[i] = -1;\n    }\n\n    // FIFO Page Replacement Algorithm\n    for (int i = 0; i < num_pages; i++) {\n        int page = reference_string[i];\n\n        // If the page is not already in memory, it's a page fault\n        if (!isPageInMemory(page, frames, n)) {\n            // Replace the page using FIFO\n            frames[current_frame] = page;\n            current_frame = (current_frame + 1) % n; // Move to the next frame in a circular manner\n            page_faults++;\n\n            printf(\"Page %d caused a page fault. Frames: \", page);\n            printFrames(frames, n);\n        } else {\n            printf(\"Page %d found in memory. No page fault.\\n\", page);\n        }\n    }\n\n    printf(\"\\nTotal number of page faults: %d\\n\", page_faults);\n\n    return 0;\n}"
    },
    {
        "id": 4,
        "slip_no": "slip 2",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following ‘list’ commands as myshell$ list f dirname :- To print names of all the files in current directory. myshell$ list n dirname :- To print the number of all entries in the current directory.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <dirent.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to handle the `list` command\nvoid listDirectory(int argc, char **args) {\n    if (argc != 3) {\n        printf(\"Usage: list f dirname OR list n dirname\\n\");\n        return;\n    }\n\n    char *dirname = args[2];\n    DIR *dir = opendir(dirname);\n    if (!dir) {\n        perror(\"Error opening directory\");\n        return;\n    }\n\n    struct dirent *entry;\n    int count = 0;\n\n    if (strcmp(args[1], \"f\") == 0) {\n        // Print names of all files in the directory\n        while ((entry = readdir(dir)) != NULL) {\n            if (entry->d_name[0] != '.') { // Exclude hidden files\n                printf(\"%s\\n\", entry->d_name);\n            }\n        }\n    } else if (strcmp(args[1], \"n\") == 0) {\n        // Count all entries in the directory\n        while ((entry = readdir(dir)) != NULL) {\n            count++;\n        }\n        printf(\"Total entries: %d\\n\", count);\n    } else {\n        printf(\"Invalid list command\\n\");\n    }\n\n    closedir(dir);\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n        // Handle the `list` command\n        if (strcmp(args[0], \"list\") == 0) {\n            listDirectory(MAX_ARGS, args);\n            continue;\n        }\n        // Fork a child process to execute the command\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 5,
        "slip_no": "slip 3",
        "question": "Write the simulation program to implement demand paging and show the page scheduling and total number of page faults according to the LRU (using counter method) page replacement algorithm. Assume the memory of n frames. Reference String : 3, 5, 7, 2, 5, 1, 2, 3, 1, 3, 5, 3, 1, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to check if a page is present in memory\nint isPageInMemory(int page, int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == page) {\n            return 1; // Page found in memory\n        }\n    }\n    return 0; // Page not found\n}\n\n// Function to print the current state of frames\nvoid printFrames(int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == -1) {\n            printf(\"- \");\n        } else {\n            printf(\"%d \", frames[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\n// Function to find the least recently used page\nint findLRU(int frames[], int lastUsed[], int n) {\n    int minIndex = 0, minCounter = lastUsed[0];\n    for (int i = 1; i < n; i++) {\n        if (lastUsed[i] < minCounter) {\n            minCounter = lastUsed[i];\n            minIndex = i;\n        }\n    }\n    return minIndex; // Return index of the least recently used page\n}\n\nint main() {\n    int n; // Number of frames\n    int frames[MAX_FRAMES], lastUsed[MAX_FRAMES];\n    int reference_string[] = {3, 5, 7, 2, 5, 1, 2, 3, 1, 3, 5, 3, 1, 6, 2};\n    int num_pages = sizeof(reference_string) / sizeof(reference_string[0]);\n    int page_faults = 0;\n\n    // Input: number of frames\n    printf(\"Enter the number of frames: \");\n    scanf(\"%d\", &n);\n\n    // Initialize frames to -1 (indicating they are empty)\n    for (int i = 0; i < n; i++) {\n        frames[i] = -1;\n        lastUsed[i] = 0; // Initialize last used counters\n    }\n\n    // LRU Page Replacement Algorithm\n    for (int i = 0; i < num_pages; i++) {\n        int page = reference_string[i];\n\n        // If the page is not already in memory, it's a page fault\n        if (!isPageInMemory(page, frames, n)) {\n            int replaceIndex = findLRU(frames, lastUsed, n); // Find LRU page index\n\n            // Replace the page\n            frames[replaceIndex] = page;\n            lastUsed[replaceIndex] = i; // Update last used counter for the replaced page\n            page_faults++;\n\n            printf(\"Page %d caused a page fault. Frames: \", page);\n            printFrames(frames, n);\n        } else {\n            // If the page is found, update the last used counter\n            for (int j = 0; j < n; j++) {\n                if (frames[j] == page) {\n                    lastUsed[j] = i; // Update last used counter for the current page\n                    break;\n                }\n            }\n            printf(\"Page %d found in memory. No page fault.\\n\", page);\n        }\n    }\n\n    printf(\"\\nTotal number of page faults: %d\\n\", page_faults);\n\n    return 0;\n}"
    },
    {
        "id": 6,
        "slip_no": "slip 3",
        "question": "Write a program to implement the toy shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands: \n count c filename :- To print number of characters in the file. \n count w filename :- To print number of words in the file. \n count l filename :- To print number of lines in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to count characters, words, or lines in a file\nvoid countFile(const char *option, const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    int characters = 0, words = 0, lines = 0;\n    char ch;\n    int inWord = 0;\n\n    while ((ch = fgetc(file)) != EOF) {\n        characters++;\n        if (ch == '\\n') {\n            lines++;\n        }\n        if (ch == ' ' || ch == '\\n' || ch == '\\t') {\n            if (inWord) {\n                inWord = 0;\n                words++;\n            }\n        } else {\n            inWord = 1;\n        }\n    }\n    if (inWord) {\n        words++; // Count the last word if the file doesn't end with a space\n    }\n\n    fclose(file);\n\n    // Print the requested count\n    if (strcmp(option, \"c\") == 0) {\n        printf(\"Character count: %d\\n\", characters);\n    } else if (strcmp(option, \"w\") == 0) {\n        printf(\"Word count: %d\\n\", words);\n    } else if (strcmp(option, \"l\") == 0) {\n        printf(\"Line count: %d\\n\", lines);\n    } else {\n        printf(\"Invalid count option.\\n\");\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n        // Check if the command is 'count'\n        if (strcmp(args[0], \"count\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                countFile(args[1], args[2]); // Call count function\n            } else {\n                printf(\"Usage: count [c|w|l] filename\\n\");\n            }\n            continue;\n        }\n        // Fork a child process to execute the command\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 7,
        "slip_no": "slip 4",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the MFU page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Structure to represent a page\ntypedef struct {\n    int page_number;\n    int frequency; // To track the number of accesses\n} Page;\n\n// Function to find the index of the most frequently used page\nint findMFU(Page pages[], int frame_count) {\n    int max_frequency = pages[0].frequency;\n    int mfu_index = 0;\n\n    for (int i = 1; i < frame_count; i++) {\n        if (pages[i].frequency > max_frequency) {\n            max_frequency = pages[i].frequency;\n            mfu_index = i;\n        }\n    }\n    return mfu_index;\n}\n\n// Function to simulate demand paging using MFU page replacement\nvoid simulateMFU(int reference_string[], int ref_length, int frame_count) {\n    Page pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < MAX_FRAMES; i++) {\n        pages[i].page_number = -1; // -1 indicates an empty frame\n        pages[i].frequency = 0;\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j].page_number == current_page) {\n                pages[j].frequency++; // Increment frequency\n                found = 1;\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames].page_number = current_page;\n                pages[current_frames].frequency = 1;\n                current_frames++;\n            } else {\n                // If memory is full, replace the most frequently used page\n                int mfu_index = findMFU(pages, frame_count);\n                pages[mfu_index].page_number = current_page;\n                pages[mfu_index].frequency = 1; // Reset frequency for the new page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d(%d) \", pages[j].page_number, pages[j].frequency);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateMFU(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 8,
        "slip_no": "slip 4",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. myshell$ search a filename pattern :- To search all the occurrence of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrence of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for occurrences of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern, int count) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int occurrences = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            occurrences++;\n            ptr += strlen(pattern); // Move past the last found occurrence\n        }\n    }\n\n    fclose(file);\n\n    if (count) {\n        printf(\"Occurrences of pattern '%s': %d\\n\", pattern, occurrences);\n    } else {\n        if (occurrences > 0) {\n            printf(\"Pattern '%s' found in file '%s'.\\n\", pattern, filename);\n        } else {\n            printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n        }\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 1); // Count mode\n                    } else {\n                        printf(\"Usage: search c filename pattern\\n\");\n                    }\n                } else {\n                    // Search mode\n                    searchInFile(args[1], args[2], 0); // Search mode\n                }\n            } else {\n                printf(\"Usage: search [c] filename pattern\\n\");\n            }\n            continue;\n        }\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 9,
        "slip_no": "slip 5",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the optimal page replacement algorithm. Assume the memory of n frames. Reference String : 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to find the index of the page to be replaced using the Optimal page replacement algorithm\nint findOptimal(int pages[], int n, int frame_count, int current_index) {\n    int optimal_index = -1;\n    int farthest = current_index;\n\n    for (int i = 0; i < frame_count; i++) {\n        int j;\n        // Check if the page is in the frame\n        for (j = current_index; j < n; j++) {\n            if (pages[j] == pages[i]) {\n                // Found the page in future references\n                if (j > farthest) {\n                    farthest = j;\n                    optimal_index = i;\n                }\n                break;\n            }\n        }\n        // If the page is not found in the future references, it can be replaced\n        if (j == n) {\n            return i; // Replace this page\n        }\n    }\n    // If all pages are found in future references, replace the optimal index\n    return (optimal_index != -1) ? optimal_index : 0;\n}\n\n// Function to simulate demand paging using the Optimal page replacement algorithm\nvoid simulateOptimal(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the optimal page\n                int optimal_index = findOptimal(pages, ref_length, frame_count, i + 1);\n                pages[optimal_index] = current_page; // Replace the optimal page\n            }\n        }\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateOptimal(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 10,
        "slip_no": "slip 5",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrence of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern, int count) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int occurrences = 0;\n    int first_occurrence_line = -1;\n    int line_number = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        char *ptr = strstr(line, pattern);\n        if (ptr != NULL) {\n            occurrences++;\n            if (first_occurrence_line == -1) {\n                first_occurrence_line = line_number;\n            }\n            if (count) {\n                // If counting, continue checking\n                continue;\n            } else {\n                printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n                fclose(file);\n                return;\n            }\n        }\n    }\n\n    fclose(file);\n\n    if (count) {\n        printf(\"Total occurrences of pattern '%s': %d\\n\", pattern, occurrences);\n    } else if (first_occurrence_line == -1) {\n        printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 0); // Search mode\n                    } else {\n                        printf(\"Usage: search f filename pattern\\n\");\n                    }\n                } else if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 1); // Count mode\n                    } else {\n                        printf(\"Usage: search c filename pattern\\n\");\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'c' for count.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/c] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 11,
        "slip_no": "slip 6",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the MRU page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to simulate demand paging using the MRU page replacement algorithm\nvoid simulateMRU(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        bool found = false;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = true; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the MRU page\n                int mru_index = 0;\n                for (int j = 1; j < frame_count; j++) {\n                    if (pages[j] > pages[mru_index]) {\n                        mru_index = j;\n                    }\n                }\n                pages[mru_index] = current_page; // Replace the MRU page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateMRU(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 12,
        "slip_no": "slip 6",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following commands: myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search a filename pattern :- To search all the occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern, int all) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n    int found = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        char *ptr = strstr(line, pattern);\n        if (ptr != NULL) {\n            found = 1;\n            if (!all) {\n                printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n                fclose(file);\n                return;\n            }\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n        }\n    }\n\n    fclose(file);\n\n    if (found) {\n        printf(\"All occurrences of pattern '%s' have been displayed.\\n\", pattern);\n    } else {\n        printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 0); // Search mode\n                    } else {\n                        printf(\"Usage: search f filename pattern\\n\");\n                    }\n                } else if (strcmp(args[1], \"a\") == 0) {\n                    // All occurrences\n                    if (args[2] != NULL) {\n                        searchInFile(args[2], args[3], 1); // All mode\n                    } else {\n                        printf(\"Usage: search a filename pattern\\n\");\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'a' for all occurrences.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/a] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 13,
        "slip_no": "slip 7",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the Optimal page replacement algorithm. Assume the memory of n frames. Reference String: 7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to find the index of the page to be replaced using the Optimal page replacement algorithm\nint findOptimal(int pages[], int n, int frame_count, int current_index) {\n    int optimal_index = -1;\n    int farthest = current_index;\n\n    for (int i = 0; i < frame_count; i++) {\n        int j;\n        // Check if the page is in the frame\n        for (j = current_index; j < n; j++) {\n            if (pages[i] == pages[j]) {\n                // Found the page in future references\n                if (j > farthest) {\n                    farthest = j;\n                    optimal_index = i;\n                }\n                break;\n            }\n        }\n        // If the page is not found in the future references, it can be replaced\n        if (j == n) {\n            return i; // Replace this page\n        }\n    }\n    // If all pages are found in future references, replace the optimal index\n    return (optimal_index != -1) ? optimal_index : 0;\n}\n\n// Function to simulate demand paging using the Optimal page replacement algorithm\nvoid simulateOptimal(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the optimal page\n                int optimal_index = findOptimal(pages, ref_length, frame_count, i + 1);\n                pages[optimal_index] = current_page; // Replace the optimal page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateOptimal(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 14,
        "slip_no": "slip 7",
        "question": "Write a program to implement shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following commands: myshell$ search a filename pattern :- To search all the occurrences of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for all occurrences of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n    int found = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, pattern) != NULL) {\n            found = 1;\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n        }\n    }\n\n    fclose(file);\n\n    if (!found) {\n        printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n    }\n}\n\n// Function to count occurrences of a pattern in a file\nint countOccurrencesInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            count++;\n            ptr++;\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"a\") == 0) {\n                    // All occurrences\n                    searchInFile(args[2], args[3]); // Search mode\n                } else if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    int count = countOccurrencesInFile(args[2], args[3]);\n                    if (count != -1) {\n                        printf(\"Total occurrences of '%s' in '%s': %d\\n\", args[3], args[2], count);\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'a' for all occurrences or 'c' for count.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [a/c] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 15,
        "slip_no": "slip 8",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the LRU page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to find the index of the page to be replaced using the LRU page replacement algorithm\nint findLRU(int pages[], int n, int frame_count, int current_index) {\n    int lru_index = -1;\n    int lru_time = -1;\n\n    for (int i = 0; i < frame_count; i++) {\n        // Find the least recently used page\n        if (pages[i] == -1) {\n            return i; // If there is an empty frame\n        }\n        int last_used_time = 0;\n        for (int j = current_index - 1; j >= 0; j--) {\n            if (pages[i] == pages[j]) {\n                last_used_time = j;\n                break;\n            }\n        }\n        if (last_used_time > lru_time) {\n            lru_time = last_used_time;\n            lru_index = i;\n        }\n    }\n    return lru_index;\n}\n\n// Function to simulate demand paging using the LRU page replacement algorithm\nvoid simulateLRU(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the least recently used page\n                int lru_index = findLRU(pages, ref_length, frame_count, i);\n                pages[lru_index] = current_page; // Replace the LRU page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateLRU(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 16,
        "slip_no": "slip 8",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands: myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, pattern) != NULL) {\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n            break;\n        }\n    }\n\n    fclose(file);\n}\n\n// Function to count occurrences of a pattern in a file\nint countOccurrencesInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            count++;\n            ptr++;\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    searchInFile(args[2], args[3]); // Search mode\n                } else if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    int count = countOccurrencesInFile(args[2], args[3]);\n                    if (count != -1) {\n                        printf(\"Total occurrences of '%s' in '%s': %d\\n\", args[3], args[2], count);\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'c' for count.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/c] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 17,
        "slip_no": "slip 9",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the FIFO page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to simulate demand paging using the FIFO page replacement algorithm\nvoid simulateFIFO(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n    int page_index = 0; // To track the next page to replace\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the oldest page (FIFO)\n                pages[page_index] = current_page; // Replace the oldest page\n                page_index = (page_index + 1) % frame_count; // Move to the next index\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateFIFO(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 18,
        "slip_no": "slip 9",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands: myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search a filename pattern :- To search all the occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, pattern) != NULL) {\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n            break;\n        }\n    }\n\n    fclose(file);\n}\n\n// Function to count occurrences of a pattern in a file\nint countOccurrencesInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            count++;\n            ptr++;\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    searchInFile(args[2], args[3]); // Search mode\n                } else if (strcmp(args[1], \"a\") == 0) {\n                    // Search all occurrences\n                    int count = countOccurrencesInFile(args[2], args[3]);\n                    if (count != -1) {\n                        printf(\"Total occurrences of '%s' in '%s': %d\\n\", args[3], args[2], count);\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'a' for all occurrences.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/a] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 19,
        "slip_no": "slip 10",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the FIFO page replacement algorithm. Assume the memory of n frames. Reference String: 2, 4, 5, 6, 9, 4, 7, 3, 4, 5, 6, 7, 2, 4, 7, 1.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to simulate demand paging using the FIFO page replacement algorithm\nvoid simulateFIFO(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n    int page_index = 0; // To track the next page to replace\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the oldest page (FIFO)\n                pages[page_index] = current_page; // Replace the oldest page\n                page_index = (page_index + 1) % frame_count; // Move to the next index\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {2, 4, 5, 6, 9, 4, 7, 3, 4, 5, 6, 7, 2, 4, 7, 1};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateFIFO(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 20,
        "slip_no": "slip 10",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following ‘list’ commands as myshell$ list f dirname :- To print names of all the files in current directory. myshell$ list i dirname :- To print names and inodes of the files in the current directory.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <sys/stat.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to list files in a directory\nvoid listFiles(const char *dirname, int show_inodes) {\n    DIR *dir;\n    struct dirent *entry;\n    struct stat fileStat;\n    char path[MAX_LINE];\n\n    // Open the directory\n    dir = opendir(dirname);\n    if (dir == NULL) {\n        perror(\"Error opening directory\");\n        return;\n    }\n\n    // Read and list the files\n    while ((entry = readdir(dir)) != NULL) {\n        // Skip current and parent directory entries\n        if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        // Print file name or inode\n        if (show_inodes) {\n            snprintf(path, sizeof(path), \"%s/%s\", dirname, entry->d_name);\n            if (stat(path, &fileStat) == 0) {\n                printf(\"File: %s, Inode: %lu\\n\", entry->d_name, fileStat.st_ino);\n            }\n        } else {\n            printf(\"%s\\n\", entry->d_name);\n        }\n    }\n\n    closedir(dir);\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `list` command\n        if (strcmp(args[0], \"list\") == 0 && args[1] != NULL) {\n            if (strcmp(args[1], \"f\") == 0 && args[2] != NULL) {\n                listFiles(args[2], 0); // List file names\n            } else if (strcmp(args[1], \"i\") == 0 && args[2] != NULL) {\n                listFiles(args[2], 1); // List file names and inodes\n            } else {\n                printf(\"Usage: list [f/i] dirname\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    }
]