[
    {
        "id": 1,
        "slip_no": "slip 1",
        "question": "Write the simulation program to implement demand paging and show the page scheduling and total number of page faults according to the LFU page replacement algorithm. Assume the memory of n frames. Reference String : 3,4,5,4,3,4,7,2,4,5,6,7,2,4,6.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n// Function to find the index of the least frequently used page\nint findLFU(int frames[], int freq[], int n) {\n    int min = INT_MAX, min_index = -1;\n    for (int i = 0; i < n; i++) {\n        if (freq[i] < min) {\n            min = freq[i];\n            min_index = i;\n        }\n    }\n    return min_index;\n}\n\n// Function to check if a page is present in the frames\nint isPresent(int frames[], int page, int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == page)\n            return i;\n    }\n    return -1;\n}\n\nint main() {\n    int n, num_pages;\n    int frames[MAX_FRAMES], freq[MAX_FRAMES], ref_str[MAX_PAGES];\n    int page_faults = 0;\n\n    // Initialize frames and frequency\n    for (int i = 0; i < MAX_FRAMES; i++) {\n        frames[i] = -1;\n        freq[i] = 0;\n    }\n\n    // Input: number of frames\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &n);\n\n    // Input: reference string\n    printf(\"Enter the number of pages in the reference string: \");\n    scanf(\"%d\", &num_pages);\n    printf(\"Enter reference string: \");\n    for (int i = 0; i < num_pages; i++) {\n        scanf(\"%d\", &ref_str[i]);\n    }\n\n    // Page scheduling and LFU algorithm\n    for (int i = 0; i < num_pages; i++) {\n        int page = ref_str[i];\n        int pos = isPresent(frames, page, n);\n\n        // Page is not present in memory, a page fault occurs\n        if (pos == -1) {\n            // Find a free frame or replace the least frequently used page\n            int replace_index = findLFU(frames, freq, n);\n\n            // Replace the page and update frequency\n            frames[replace_index] = page;\n            freq[replace_index] = 1; // Reset frequency for the new page\n            page_faults++;\n\n            // Display frames content\n            printf(\"Page %d caused a page fault. Frames: \", page);\n            for (int j = 0; j < n; j++) {\n                if (frames[j] != -1)\n                    printf(\"%d \", frames[j]);\n                else\n                    printf(\"- \");\n            }\n            printf(\"\\n\");\n        } else {\n            // Page is already in memory, just update its frequency\n            freq[pos]++;\n            printf(\"Page %d found in memory. No page fault.\\n\", page);\n        }\n    }\n\n    printf(\"\\nTotal page faults: %d\\n\", page_faults);\n    return 0;\n}"
    },
    {
        "id": 2,
        "slip_no": "slip 1",
        "question": "Write a C program to implement the shell which displays the command prompt 'myshell$'. It accepts the command, tokenize the command line and execute it by creating the child process. Also implement the additional command 'typeline' as typeline +n filename :- To print first n lines in the file. typeline -a filename :- To print all lines in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <fcntl.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to handle the 'typeline' command\nvoid typeline(int argc, char **args) {\n    if (argc != 3) {\n        printf(\"Usage: typeline +n filename OR typeline -a filename\\n\");\n        return;\n    }\n\n    char *filename = args[2];\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    if (strcmp(args[1], \"-a\") == 0) {\n        // Print all lines\n        while (fgets(line, sizeof(line), file)) {\n            printf(\"%s\", line);\n        }\n    } else if (args[1][0] == '+' && atoi(args[1] + 1) > 0) {\n        // Print first n lines\n        int n = atoi(args[1] + 1);\n        while (fgets(line, sizeof(line), file) && count < n) {\n            printf(\"%s\", line);\n            count++;\n        }\n    } else {\n        printf(\"Invalid typeline command\\n\");\n    }\n\n    fclose(file);\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for 'exit' command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Handle the 'typeline' command\n        if (strcmp(args[0], \"typeline\") == 0) {\n            typeline(MAX_ARGS, args);\n            continue;\n        }\n\n        // Fork a child process to execute the command\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 3,
        "slip_no": "slip 2",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the FIFO page replacement algorithm. Assume the memory of n frames. Reference String: 3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6.",
        "language": "c",
        "code": "#include <stdio.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to check if a page is present in memory\nint isPageInMemory(int page, int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == page) {\n            return 1; // Page found in memory\n        }\n    }\n    return 0; // Page not found\n}\n\n// Function to print the current state of frames\nvoid printFrames(int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == -1) {\n            printf(\"- \");\n        } else {\n            printf(\"%d \", frames[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\nint main() {\n    int n; // Number of frames\n    int frames[MAX_FRAMES], reference_string[] = {3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};\n    int num_pages = sizeof(reference_string) / sizeof(reference_string[0]);\n    int page_faults = 0;\n    int current_frame = 0; // To keep track of the next frame to replace (FIFO)\n\n    // Input: number of frames\n    printf(\"Enter the number of frames: \");\n    scanf(\"%d\", &n);\n\n    // Initialize frames to -1 (indicating they are empty)\n    for (int i = 0; i < n; i++) {\n        frames[i] = -1;\n    }\n\n    // FIFO Page Replacement Algorithm\n    for (int i = 0; i < num_pages; i++) {\n        int page = reference_string[i];\n\n        // If the page is not already in memory, it's a page fault\n        if (!isPageInMemory(page, frames, n)) {\n            // Replace the page using FIFO\n            frames[current_frame] = page;\n            current_frame = (current_frame + 1) % n; // Move to the next frame in a circular manner\n            page_faults++;\n\n            printf(\"Page %d caused a page fault. Frames: \", page);\n            printFrames(frames, n);\n        } else {\n            printf(\"Page %d found in memory. No page fault.\\n\", page);\n        }\n    }\n\n    printf(\"\\nTotal number of page faults: %d\\n\", page_faults);\n\n    return 0;\n}"
    },
    {
        "id": 4,
        "slip_no": "slip 2",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following ‘list’ commands as myshell$ list f dirname :- To print names of all the files in current directory. myshell$ list n dirname :- To print the number of all entries in the current directory.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <dirent.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to handle the `list` command\nvoid listDirectory(int argc, char **args) {\n    if (argc != 3) {\n        printf(\"Usage: list f dirname OR list n dirname\\n\");\n        return;\n    }\n\n    char *dirname = args[2];\n    DIR *dir = opendir(dirname);\n    if (!dir) {\n        perror(\"Error opening directory\");\n        return;\n    }\n\n    struct dirent *entry;\n    int count = 0;\n\n    if (strcmp(args[1], \"f\") == 0) {\n        // Print names of all files in the directory\n        while ((entry = readdir(dir)) != NULL) {\n            if (entry->d_name[0] != '.') { // Exclude hidden files\n                printf(\"%s\\n\", entry->d_name);\n            }\n        }\n    } else if (strcmp(args[1], \"n\") == 0) {\n        // Count all entries in the directory\n        while ((entry = readdir(dir)) != NULL) {\n            count++;\n        }\n        printf(\"Total entries: %d\\n\", count);\n    } else {\n        printf(\"Invalid list command\\n\");\n    }\n\n    closedir(dir);\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n        // Handle the `list` command\n        if (strcmp(args[0], \"list\") == 0) {\n            listDirectory(MAX_ARGS, args);\n            continue;\n        }\n        // Fork a child process to execute the command\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 5,
        "slip_no": "slip 3",
        "question": "Write the simulation program to implement demand paging and show the page scheduling and total number of page faults according to the LRU (using counter method) page replacement algorithm. Assume the memory of n frames. Reference String : 3, 5, 7, 2, 5, 1, 2, 3, 1, 3, 5, 3, 1, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to check if a page is present in memory\nint isPageInMemory(int page, int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == page) {\n            return 1; // Page found in memory\n        }\n    }\n    return 0; // Page not found\n}\n\n// Function to print the current state of frames\nvoid printFrames(int frames[], int n) {\n    for (int i = 0; i < n; i++) {\n        if (frames[i] == -1) {\n            printf(\"- \");\n        } else {\n            printf(\"%d \", frames[i]);\n        }\n    }\n    printf(\"\\n\");\n}\n\n// Function to find the least recently used page\nint findLRU(int frames[], int lastUsed[], int n) {\n    int minIndex = 0, minCounter = lastUsed[0];\n    for (int i = 1; i < n; i++) {\n        if (lastUsed[i] < minCounter) {\n            minCounter = lastUsed[i];\n            minIndex = i;\n        }\n    }\n    return minIndex; // Return index of the least recently used page\n}\n\nint main() {\n    int n; // Number of frames\n    int frames[MAX_FRAMES], lastUsed[MAX_FRAMES];\n    int reference_string[] = {3, 5, 7, 2, 5, 1, 2, 3, 1, 3, 5, 3, 1, 6, 2};\n    int num_pages = sizeof(reference_string) / sizeof(reference_string[0]);\n    int page_faults = 0;\n\n    // Input: number of frames\n    printf(\"Enter the number of frames: \");\n    scanf(\"%d\", &n);\n\n    // Initialize frames to -1 (indicating they are empty)\n    for (int i = 0; i < n; i++) {\n        frames[i] = -1;\n        lastUsed[i] = 0; // Initialize last used counters\n    }\n\n    // LRU Page Replacement Algorithm\n    for (int i = 0; i < num_pages; i++) {\n        int page = reference_string[i];\n\n        // If the page is not already in memory, it's a page fault\n        if (!isPageInMemory(page, frames, n)) {\n            int replaceIndex = findLRU(frames, lastUsed, n); // Find LRU page index\n\n            // Replace the page\n            frames[replaceIndex] = page;\n            lastUsed[replaceIndex] = i; // Update last used counter for the replaced page\n            page_faults++;\n\n            printf(\"Page %d caused a page fault. Frames: \", page);\n            printFrames(frames, n);\n        } else {\n            // If the page is found, update the last used counter\n            for (int j = 0; j < n; j++) {\n                if (frames[j] == page) {\n                    lastUsed[j] = i; // Update last used counter for the current page\n                    break;\n                }\n            }\n            printf(\"Page %d found in memory. No page fault.\\n\", page);\n        }\n    }\n\n    printf(\"\\nTotal number of page faults: %d\\n\", page_faults);\n\n    return 0;\n}"
    },
    {
        "id": 6,
        "slip_no": "slip 3",
        "question": "Write a program to implement the toy shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands: \n count c filename :- To print number of characters in the file. \n count w filename :- To print number of words in the file. \n count l filename :- To print number of lines in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to count characters, words, or lines in a file\nvoid countFile(const char *option, const char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    int characters = 0, words = 0, lines = 0;\n    char ch;\n    int inWord = 0;\n\n    while ((ch = fgetc(file)) != EOF) {\n        characters++;\n        if (ch == '\\n') {\n            lines++;\n        }\n        if (ch == ' ' || ch == '\\n' || ch == '\\t') {\n            if (inWord) {\n                inWord = 0;\n                words++;\n            }\n        } else {\n            inWord = 1;\n        }\n    }\n    if (inWord) {\n        words++; // Count the last word if the file doesn't end with a space\n    }\n\n    fclose(file);\n\n    // Print the requested count\n    if (strcmp(option, \"c\") == 0) {\n        printf(\"Character count: %d\\n\", characters);\n    } else if (strcmp(option, \"w\") == 0) {\n        printf(\"Word count: %d\\n\", words);\n    } else if (strcmp(option, \"l\") == 0) {\n        printf(\"Line count: %d\\n\", lines);\n    } else {\n        printf(\"Invalid count option.\\n\");\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n        // Check if the command is 'count'\n        if (strcmp(args[0], \"count\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                countFile(args[1], args[2]); // Call count function\n            } else {\n                printf(\"Usage: count [c|w|l] filename\\n\");\n            }\n            continue;\n        }\n        // Fork a child process to execute the command\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 7,
        "slip_no": "slip 4",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the MFU page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Structure to represent a page\ntypedef struct {\n    int page_number;\n    int frequency; // To track the number of accesses\n} Page;\n\n// Function to find the index of the most frequently used page\nint findMFU(Page pages[], int frame_count) {\n    int max_frequency = pages[0].frequency;\n    int mfu_index = 0;\n\n    for (int i = 1; i < frame_count; i++) {\n        if (pages[i].frequency > max_frequency) {\n            max_frequency = pages[i].frequency;\n            mfu_index = i;\n        }\n    }\n    return mfu_index;\n}\n\n// Function to simulate demand paging using MFU page replacement\nvoid simulateMFU(int reference_string[], int ref_length, int frame_count) {\n    Page pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < MAX_FRAMES; i++) {\n        pages[i].page_number = -1; // -1 indicates an empty frame\n        pages[i].frequency = 0;\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j].page_number == current_page) {\n                pages[j].frequency++; // Increment frequency\n                found = 1;\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames].page_number = current_page;\n                pages[current_frames].frequency = 1;\n                current_frames++;\n            } else {\n                // If memory is full, replace the most frequently used page\n                int mfu_index = findMFU(pages, frame_count);\n                pages[mfu_index].page_number = current_page;\n                pages[mfu_index].frequency = 1; // Reset frequency for the new page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d(%d) \", pages[j].page_number, pages[j].frequency);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateMFU(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 8,
        "slip_no": "slip 4",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. myshell$ search a filename pattern :- To search all the occurrence of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrence of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \\n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \\n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for occurrences of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern, int count) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int occurrences = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            occurrences++;\n            ptr += strlen(pattern); // Move past the last found occurrence\n        }\n    }\n\n    fclose(file);\n\n    if (count) {\n        printf(\"Occurrences of pattern '%s': %d\\n\", pattern, occurrences);\n    } else {\n        if (occurrences > 0) {\n            printf(\"Pattern '%s' found in file '%s'.\\n\", pattern, filename);\n        } else {\n            printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n        }\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 1); // Count mode\n                    } else {\n                        printf(\"Usage: search c filename pattern\\n\");\n                    }\n                } else {\n                    // Search mode\n                    searchInFile(args[1], args[2], 0); // Search mode\n                }\n            } else {\n                printf(\"Usage: search [c] filename pattern\\n\");\n            }\n            continue;\n        }\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 9,
        "slip_no": "slip 5",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the optimal page replacement algorithm. Assume the memory of n frames. Reference String : 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to find the index of the page to be replaced using the Optimal page replacement algorithm\nint findOptimal(int pages[], int n, int frame_count, int current_index) {\n    int optimal_index = -1;\n    int farthest = current_index;\n\n    for (int i = 0; i < frame_count; i++) {\n        int j;\n        // Check if the page is in the frame\n        for (j = current_index; j < n; j++) {\n            if (pages[j] == pages[i]) {\n                // Found the page in future references\n                if (j > farthest) {\n                    farthest = j;\n                    optimal_index = i;\n                }\n                break;\n            }\n        }\n        // If the page is not found in the future references, it can be replaced\n        if (j == n) {\n            return i; // Replace this page\n        }\n    }\n    // If all pages are found in future references, replace the optimal index\n    return (optimal_index != -1) ? optimal_index : 0;\n}\n\n// Function to simulate demand paging using the Optimal page replacement algorithm\nvoid simulateOptimal(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the optimal page\n                int optimal_index = findOptimal(pages, ref_length, frame_count, i + 1);\n                pages[optimal_index] = current_page; // Replace the optimal page\n            }\n        }\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateOptimal(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 10,
        "slip_no": "slip 5",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrence of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern, int count) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int occurrences = 0;\n    int first_occurrence_line = -1;\n    int line_number = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        char *ptr = strstr(line, pattern);\n        if (ptr != NULL) {\n            occurrences++;\n            if (first_occurrence_line == -1) {\n                first_occurrence_line = line_number;\n            }\n            if (count) {\n                // If counting, continue checking\n                continue;\n            } else {\n                printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n                fclose(file);\n                return;\n            }\n        }\n    }\n\n    fclose(file);\n\n    if (count) {\n        printf(\"Total occurrences of pattern '%s': %d\\n\", pattern, occurrences);\n    } else if (first_occurrence_line == -1) {\n        printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 0); // Search mode\n                    } else {\n                        printf(\"Usage: search f filename pattern\\n\");\n                    }\n                } else if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 1); // Count mode\n                    } else {\n                        printf(\"Usage: search c filename pattern\\n\");\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'c' for count.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/c] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            // If execvp fails\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 11,
        "slip_no": "slip 6",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the MRU page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to simulate demand paging using the MRU page replacement algorithm\nvoid simulateMRU(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        bool found = false;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = true; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the MRU page\n                int mru_index = 0;\n                for (int j = 1; j < frame_count; j++) {\n                    if (pages[j] > pages[mru_index]) {\n                        mru_index = j;\n                    }\n                }\n                pages[mru_index] = current_page; // Replace the MRU page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateMRU(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 12,
        "slip_no": "slip 6",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following commands: myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search a filename pattern :- To search all the occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern, int all) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n    int found = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        char *ptr = strstr(line, pattern);\n        if (ptr != NULL) {\n            found = 1;\n            if (!all) {\n                printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n                fclose(file);\n                return;\n            }\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n        }\n    }\n\n    fclose(file);\n\n    if (found) {\n        printf(\"All occurrences of pattern '%s' have been displayed.\\n\", pattern);\n    } else {\n        printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n    }\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    if (args[3] != NULL) {\n                        searchInFile(args[2], args[3], 0); // Search mode\n                    } else {\n                        printf(\"Usage: search f filename pattern\\n\");\n                    }\n                } else if (strcmp(args[1], \"a\") == 0) {\n                    // All occurrences\n                    if (args[2] != NULL) {\n                        searchInFile(args[2], args[3], 1); // All mode\n                    } else {\n                        printf(\"Usage: search a filename pattern\\n\");\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'a' for all occurrences.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/a] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            exit(1);\n        } else if (pid == 0) {\n            // Child process: Execute the command\n            execvp(args[0], args);\n            perror(\"Command execution failed\");\n            exit(1);\n        } else {\n            // Parent process: Wait for the child to finish\n            wait(NULL);\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 13,
        "slip_no": "slip 7",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the Optimal page replacement algorithm. Assume the memory of n frames. Reference String: 7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to find the index of the page to be replaced using the Optimal page replacement algorithm\nint findOptimal(int pages[], int n, int frame_count, int current_index) {\n    int optimal_index = -1;\n    int farthest = current_index;\n\n    for (int i = 0; i < frame_count; i++) {\n        int j;\n        // Check if the page is in the frame\n        for (j = current_index; j < n; j++) {\n            if (pages[i] == pages[j]) {\n                // Found the page in future references\n                if (j > farthest) {\n                    farthest = j;\n                    optimal_index = i;\n                }\n                break;\n            }\n        }\n        // If the page is not found in the future references, it can be replaced\n        if (j == n) {\n            return i; // Replace this page\n        }\n    }\n    // If all pages are found in future references, replace the optimal index\n    return (optimal_index != -1) ? optimal_index : 0;\n}\n\n// Function to simulate demand paging using the Optimal page replacement algorithm\nvoid simulateOptimal(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the optimal page\n                int optimal_index = findOptimal(pages, ref_length, frame_count, i + 1);\n                pages[optimal_index] = current_page; // Replace the optimal page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateOptimal(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 14,
        "slip_no": "slip 7",
        "question": "Write a program to implement shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following commands: myshell$ search a filename pattern :- To search all the occurrences of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for all occurrences of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n    int found = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, pattern) != NULL) {\n            found = 1;\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n        }\n    }\n\n    fclose(file);\n\n    if (!found) {\n        printf(\"Pattern '%s' not found in file '%s'.\\n\", pattern, filename);\n    }\n}\n\n// Function to count occurrences of a pattern in a file\nint countOccurrencesInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            count++;\n            ptr++;\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"a\") == 0) {\n                    // All occurrences\n                    searchInFile(args[2], args[3]); // Search mode\n                } else if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    int count = countOccurrencesInFile(args[2], args[3]);\n                    if (count != -1) {\n                        printf(\"Total occurrences of '%s' in '%s': %d\\n\", args[3], args[2], count);\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'a' for all occurrences or 'c' for count.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [a/c] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 15,
        "slip_no": "slip 8",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the LRU page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to find the index of the page to be replaced using the LRU page replacement algorithm\nint findLRU(int pages[], int n, int frame_count, int current_index) {\n    int lru_index = -1;\n    int lru_time = -1;\n\n    for (int i = 0; i < frame_count; i++) {\n        // Find the least recently used page\n        if (pages[i] == -1) {\n            return i; // If there is an empty frame\n        }\n        int last_used_time = 0;\n        for (int j = current_index - 1; j >= 0; j--) {\n            if (pages[i] == pages[j]) {\n                last_used_time = j;\n                break;\n            }\n        }\n        if (last_used_time > lru_time) {\n            lru_time = last_used_time;\n            lru_index = i;\n        }\n    }\n    return lru_index;\n}\n\n// Function to simulate demand paging using the LRU page replacement algorithm\nvoid simulateLRU(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the least recently used page\n                int lru_index = findLRU(pages, ref_length, frame_count, i);\n                pages[lru_index] = current_page; // Replace the LRU page\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateLRU(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 16,
        "slip_no": "slip 8",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands: myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search c filename pattern :- To count the number of occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, pattern) != NULL) {\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n            break;\n        }\n    }\n\n    fclose(file);\n}\n\n// Function to count occurrences of a pattern in a file\nint countOccurrencesInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            count++;\n            ptr++;\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    searchInFile(args[2], args[3]); // Search mode\n                } else if (strcmp(args[1], \"c\") == 0) {\n                    // Count occurrences\n                    int count = countOccurrencesInFile(args[2], args[3]);\n                    if (count != -1) {\n                        printf(\"Total occurrences of '%s' in '%s': %d\\n\", args[3], args[2], count);\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'c' for count.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/c] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 17,
        "slip_no": "slip 9",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the FIFO page replacement algorithm. Assume the memory of n frames. Reference String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to simulate demand paging using the FIFO page replacement algorithm\nvoid simulateFIFO(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n    int page_index = 0; // To track the next page to replace\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the oldest page (FIFO)\n                pages[page_index] = current_page; // Replace the oldest page\n                page_index = (page_index + 1) % frame_count; // Move to the next index\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 9, 4, 6, 2};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateFIFO(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 18,
        "slip_no": "slip 9",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands: myshell$ search f filename pattern :- To display first occurrence of pattern in the file. myshell$ search a filename pattern :- To search all the occurrences of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to search for the first occurrence of a pattern in a file\nvoid searchInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return;\n    }\n\n    char line[MAX_LINE];\n    int line_number = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        line_number++;\n        if (strstr(line, pattern) != NULL) {\n            printf(\"Pattern '%s' found in file '%s' at line %d.\\n\", pattern, filename, line_number);\n            break;\n        }\n    }\n\n    fclose(file);\n}\n\n// Function to count occurrences of a pattern in a file\nint countOccurrencesInFile(const char *filename, const char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (!file) {\n        perror(\"Error opening file\");\n        return -1;\n    }\n\n    char line[MAX_LINE];\n    int count = 0;\n\n    // Read the file line by line\n    while (fgets(line, sizeof(line), file)) {\n        char *ptr = line;\n        while ((ptr = strstr(ptr, pattern)) != NULL) {\n            count++;\n            ptr++;\n        }\n    }\n\n    fclose(file);\n    return count;\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `search` command\n        if (strcmp(args[0], \"search\") == 0) {\n            if (args[1] != NULL && args[2] != NULL) {\n                if (strcmp(args[1], \"f\") == 0) {\n                    // First occurrence\n                    searchInFile(args[2], args[3]); // Search mode\n                } else if (strcmp(args[1], \"a\") == 0) {\n                    // Search all occurrences\n                    int count = countOccurrencesInFile(args[2], args[3]);\n                    if (count != -1) {\n                        printf(\"Total occurrences of '%s' in '%s': %d\\n\", args[3], args[2], count);\n                    }\n                } else {\n                    printf(\"Invalid search option. Use 'f' for first occurrence or 'a' for all occurrences.\\n\");\n                }\n            } else {\n                printf(\"Usage: search [f/a] filename pattern\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 19,
        "slip_no": "slip 10",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the FIFO page replacement algorithm. Assume the memory of n frames. Reference String: 2, 4, 5, 6, 9, 4, 7, 3, 4, 5, 6, 7, 2, 4, 7, 1.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_FRAMES 10\n#define MAX_PAGES 100\n\n// Function to simulate demand paging using the FIFO page replacement algorithm\nvoid simulateFIFO(int reference_string[], int ref_length, int frame_count) {\n    int pages[MAX_FRAMES];\n    int page_faults = 0;\n    int current_frames = 0;\n    int page_index = 0; // To track the next page to replace\n\n    // Initialize the page frames\n    for (int i = 0; i < frame_count; i++) {\n        pages[i] = -1; // -1 indicates an empty frame\n    }\n\n    // Process the reference string\n    for (int i = 0; i < ref_length; i++) {\n        int current_page = reference_string[i];\n        int found = 0;\n\n        // Check if the page is already in memory\n        for (int j = 0; j < current_frames; j++) {\n            if (pages[j] == current_page) {\n                found = 1; // Page hit\n                break;\n            }\n        }\n\n        // Page fault occurs\n        if (!found) {\n            page_faults++;\n            if (current_frames < frame_count) {\n                // If there is space in memory, add the new page\n                pages[current_frames] = current_page;\n                current_frames++;\n            } else {\n                // If memory is full, replace the oldest page (FIFO)\n                pages[page_index] = current_page; // Replace the oldest page\n                page_index = (page_index + 1) % frame_count; // Move to the next index\n            }\n        }\n\n        // Display the current page frames\n        printf(\"Reference: %d -> Frames: \", current_page);\n        for (int j = 0; j < current_frames; j++) {\n            printf(\"%d \", pages[j]);\n        }\n        printf(\"\\n\");\n    }\n\n    // Print the total number of page faults\n    printf(\"Total Page Faults: %d\\n\", page_faults);\n}\n\nint main() {\n    int reference_string[] = {2, 4, 5, 6, 9, 4, 7, 3, 4, 5, 6, 7, 2, 4, 7, 1};\n    int ref_length = sizeof(reference_string) / sizeof(reference_string[0]);\n    int frame_count = 3; // Set the number of frames in memory\n\n    simulateFIFO(reference_string, ref_length, frame_count);\n\n    return 0;\n}"
    },
    {
        "id": 20,
        "slip_no": "slip 10",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following ‘list’ commands as myshell$ list f dirname :- To print names of all the files in current directory. myshell$ list i dirname :- To print names and inodes of the files in the current directory.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <sys/stat.h>\n\n#define MAX_ARGS 100\n#define MAX_LINE 1024\n\n// Function to tokenize the command input\nvoid tokenize(char *input, char **args) {\n    char *token = strtok(input, \" \n\");\n    int i = 0;\n    while (token != NULL) {\n        args[i++] = token;\n        token = strtok(NULL, \" \n\");\n    }\n    args[i] = NULL;\n}\n\n// Function to list files in a directory\nvoid listFiles(const char *dirname, int show_inodes) {\n    DIR *dir;\n    struct dirent *entry;\n    struct stat fileStat;\n    char path[MAX_LINE];\n\n    // Open the directory\n    dir = opendir(dirname);\n    if (dir == NULL) {\n        perror(\"Error opening directory\");\n        return;\n    }\n\n    // Read and list the files\n    while ((entry = readdir(dir)) != NULL) {\n        // Skip current and parent directory entries\n        if (strcmp(entry->d_name, \".\") == 0 || strcmp(entry->d_name, \"..\") == 0) {\n            continue;\n        }\n\n        // Print file name or inode\n        if (show_inodes) {\n            snprintf(path, sizeof(path), \"%s/%s\", dirname, entry->d_name);\n            if (stat(path, &fileStat) == 0) {\n                printf(\"File: %s, Inode: %lu\\n\", entry->d_name, fileStat.st_ino);\n            }\n        } else {\n            printf(\"%s\\n\", entry->d_name);\n        }\n    }\n\n    closedir(dir);\n}\n\nint main() {\n    char input[MAX_LINE];\n    char *args[MAX_ARGS];\n\n    while (1) {\n        printf(\"myshell$ \"); // Display the shell prompt\n        if (fgets(input, sizeof(input), stdin) == NULL) {\n            break; // Exit if EOF is encountered\n        }\n\n        // Tokenize the input\n        tokenize(input, args);\n\n        if (args[0] == NULL) {\n            continue; // Empty command, continue to next loop iteration\n        }\n\n        // Check for `exit` command to quit the shell\n        if (strcmp(args[0], \"exit\") == 0) {\n            break;\n        }\n\n        // Check for `list` command\n        if (strcmp(args[0], \"list\") == 0 && args[1] != NULL) {\n            if (strcmp(args[1], \"f\") == 0 && args[2] != NULL) {\n                listFiles(args[2], 0); // List file names\n            } else if (strcmp(args[1], \"i\") == 0 && args[2] != NULL) {\n                listFiles(args[2], 1); // List file names and inodes\n            } else {\n                printf(\"Usage: list [f/i] dirname\\n\");\n            }\n            continue;\n        }\n\n        // Fork a child process to execute other commands\n        pid_t pid = fork();\n        if (pid < 0) {\n            perror(\"Fork failed\");\n            continue;\n        } else if (pid == 0) {\n            // In child process\n            execvp(args[0], args);\n            perror(\"Execution failed\"); // If execvp returns, there was an error\n            exit(1);\n        } else {\n            // In parent process\n            wait(NULL); // Wait for child process to finish\n        }\n    }\n\n    return 0;\n}"
    },
    {
        "id": 21,
        "slip_no": "slip 11",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the LFU page replacement algorithm. Assume the memory of n frames. Reference String : 3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6",
        "language": "c",
        "code": "#include<stdio.h>\n#define MAX 50\nvoid main() {\n    int reference_string[MAX], page_faults = 0, m, n, s, pages, frames;\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &pages);\n    printf(\"Enter reference string: \");\n    for(m = 0; m < pages; m++) {\n        scanf(\"%d\", &reference_string[m]);\n    }\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &frames);\n    int temp[frames];\n    for(m = 0; m < frames; m++) {\n        temp[m] = -1;\n    }\n    for(m = 0; m < pages; m++) {\n        s = 0;\n        for(n = 0; n < frames; n++) {\n            if(reference_string[m] == temp[n]) {\n                s++;\n                page_faults--;\n            }\n        }\n        page_faults++;\n        if((page_faults <= frames) && (s == 0)) {\n            temp[m] = reference_string[m];\n        } else if(s == 0) {\n            temp[(page_faults - 1) % frames] = reference_string[m];\n        }\n        printf(\"\\n\");\n        for(n = 0; n < frames; n++) {\n            if(temp[n] != -1) {\n                printf(\"%d\\t\", temp[n]);\n            } else {\n                printf(\"- \\t\");\n            }\n        }\n    }\n    printf(\"\\nTotal Page Faults: %d\", page_faults);\n}"
    },
    {
        "id": 22,
        "slip_no": "slip 11",
        "question": "Write a C program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following ‘list’ commands as: myshell$ list f dirname :- To print names of all the files in current directory. myshell$ list n dirname :- To print the number of all entries in the current directory.",
        "language": "c",
        "code": "#include<stdio.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<dirent.h>\n#include<string.h>\n#include<stdlib.h>\nvoid list_files(char *dirname) {\n    struct dirent *de;\n    DIR *dr = opendir(dirname);\n    if (dr == NULL) {\n        printf(\"Could not open directory %s\", dirname);\n        return;\n    }\n    while ((de = readdir(dr)) != NULL) {\n        printf(\"%s\\n\", de->d_name);\n    }\n    closedir(dr);\n}\nvoid count_entries(char *dirname) {\n    int count = 0;\n    struct dirent *de;\n    DIR *dr = opendir(dirname);\n    if (dr == NULL) {\n        printf(\"Could not open directory %s\", dirname);\n        return;\n    }\n    while ((de = readdir(dr)) != NULL) {\n        count++;\n    }\n    closedir(dr);\n    printf(\"Total entries: %d\\n\", count);\n}\nint main() {\n    char command[100];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, 100, stdin);\n        command[strlen(command) - 1] = '\\0'; // Remove newline\n        char *token = strtok(command, \" \");\n        if (strcmp(token, \"list\") == 0) {\n            token = strtok(NULL, \" \");\n            if (token != NULL && strcmp(token, \"f\") == 0) {\n                token = strtok(NULL, \" \");\n                list_files(token);\n            } else if (token != NULL && strcmp(token, \"n\") == 0) {\n                token = strtok(NULL, \" \");\n                count_entries(token);\n            }\n        } else if (fork() == 0) {\n            execlp(token, token, NULL);\n        } else {\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 23,
        "slip_no": "slip 12",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the LRU page replacement algorithm. Assume the memory of n frames. Reference String : 3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6",
        "language": "c",
        "code": "#include<stdio.h>\nint findLRU(int time[], int n) {\n    int i, minimum = time[0], pos = 0;\n    for(i = 1; i < n; ++i) {\n        if(time[i] < minimum) {\n            minimum = time[i];\n            pos = i;\n        }\n    }\n    return pos;\n}\nint main() {\n    int no_of_frames, no_of_pages, frames[10], pages[30], counter = 0, time[10], flag1, flag2, i, j, pos, page_faults = 0;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &no_of_frames);\n    printf(\"Enter number of pages: \");\n    scanf(\"%d\", &no_of_pages);\n    printf(\"Enter reference string: \");\n    for(i = 0; i < no_of_pages; ++i) {\n        scanf(\"%d\", &pages[i]);\n    }\n    for(i = 0; i < no_of_frames; ++i) {\n        frames[i] = -1;\n    }\n    for(i = 0; i < no_of_pages; ++i) {\n        flag1 = flag2 = 0;\n        for(j = 0; j < no_of_frames; ++j) {\n            if(frames[j] == pages[i]) {\n                counter++;\n                time[j] = counter;\n                flag1 = flag2 = 1;\n                break;\n            }\n        }\n        if(flag1 == 0) {\n            for(j = 0; j < no_of_frames; ++j) {\n                if(frames[j] == -1) {\n                    counter++;\n                    page_faults++;\n                    frames[j] = pages[i];\n                    time[j] = counter;\n                    flag2 = 1;\n                    break;\n                }\n            }\n        }\n        if(flag2 == 0) {\n            pos = findLRU(time, no_of_frames);\n            counter++;\n            page_faults++;\n            frames[pos] = pages[i];\n            time[pos] = counter;\n        }\n        printf(\"\\n\");\n        for(j = 0; j < no_of_frames; ++j) {\n            if(frames[j] != -1) {\n                printf(\"%d\\t\", frames[j]);\n            } else {\n                printf(\"- \\t\");\n            }\n        }\n    }\n    printf(\"\\nTotal Page Faults = %d\", page_faults);\n    return 0;\n}"
    },
    {
        "id": 24,
        "slip_no": "slip 12",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following ‘list’ commands as: myshell$ list f dirname :- To print names of all the files in current directory. myshell$ list n dirname :- To print the number of all entries in the current directory.",
        "language": "c",
        "code": "#include<stdio.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<dirent.h>\n#include<string.h>\n#include<stdlib.h>\nvoid list_files(char *dirname) {\n    struct dirent *de;\n    DIR *dr = opendir(dirname);\n    if (dr == NULL) {\n        printf(\"Could not open directory %s\", dirname);\n        return;\n    }\n    while ((de = readdir(dr)) != NULL) {\n        printf(\"%s\\n\", de->d_name);\n    }\n    closedir(dr);\n}\nvoid count_entries(char *dirname) {\n    int count = 0;\n    struct dirent *de;\n    DIR *dr = opendir(dirname);\n    if (dr == NULL) {\n        printf(\"Could not open directory %s\", dirname);\n        return;\n    }\n    while ((de = readdir(dr)) != NULL) {\n        count++;\n    }\n    closedir(dr);\n    printf(\"Total entries: %d\\n\", count);\n}\nint main() {\n    char command[100];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, 100, stdin);\n        command[strlen(command) - 1] = '\\0'; // Remove newline\n        char *token = strtok(command, \" \");\n        if (strcmp(token, \"list\") == 0) {\n            token = strtok(NULL, \" \");\n            if (token != NULL && strcmp(token, \"f\") == 0) {\n                token = strtok(NULL, \" \");\n                list_files(token);\n            } else if (token != NULL && strcmp(token, \"n\") == 0) {\n                token = strtok(NULL, \" \");\n                count_entries(token);\n            }\n        } else if (fork() == 0) {\n            execlp(token, token, NULL);\n        } else {\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 25,
        "slip_no": "slip 13",
        "question": "Write a C program to implement the shell which displays the command prompt “myshell$”. It accepts the command, tokenize the command line and execute it by creating the child process. Also implement the additional command ‘typeline’ as: typeline -a filename :- To print all lines in the file.",
        "language": "c",
        "code": "#include<stdio.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<string.h>\n#include<stdlib.h>\n#include<fcntl.h>\nvoid typeline_all(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    char line[256];\n    if (file == NULL) {\n        printf(\"Cannot open file %s\\n\", filename);\n        return;\n    }\n    while (fgets(line, sizeof(line), file)) {\n        printf(\"%s\", line);\n    }\n    fclose(file);\n}\nint main() {\n    char command[100];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, 100, stdin);\n        command[strlen(command) - 1] = '\\0'; // Remove newline\n        char *token = strtok(command, \" \");\n        if (strcmp(token, \"typeline\") == 0) {\n            token = strtok(NULL, \" \");\n            if (strcmp(token, \"-a\") == 0) {\n                token = strtok(NULL, \" \");\n                typeline_all(token);\n            }\n        } else if (fork() == 0) {\n            execlp(token, token, NULL);\n        } else {\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 26,
        "slip_no": "slip 13",
        "question": "Write the simulation program for Round Robin scheduling for given time quantum. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give the Gantt chart, turnaround time and waiting time for each process. Also display the average turnaround time and average waiting time.",
        "language": "c",
        "code": "#include<stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time, remaining_time;\n};\nint main() {\n    int n, i, j, time = 0, remain, flag = 0, time_quantum;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    remain = n;\n    for (i = 0; i < n; i++) {\n        printf(\"Enter arrival time and burst time for process P%d: \", i+1);\n        p[i].id = i + 1;\n        scanf(\"%d%d\", &p[i].arrival_time, &p[i].burst_time);\n        p[i].remaining_time = p[i].burst_time;\n    }\n    printf(\"Enter time quantum: \");\n    scanf(\"%d\", &time_quantum);\n    printf(\"\\nGantt Chart\\n\");\n    for (time = 0, i = 0; remain != 0;) {\n        if (p[i].remaining_time <= time_quantum && p[i].remaining_time > 0) {\n            time += p[i].remaining_time;\n            printf(\"| P%d \", p[i].id);\n            p[i].remaining_time = 0;\n            flag = 1;\n        } else if (p[i].remaining_time > 0) {\n            p[i].remaining_time -= time_quantum;\n            time += time_quantum;\n            printf(\"| P%d \", p[i].id);\n        }\n        if (p[i].remaining_time == 0 && flag == 1) {\n            remain--;\n            p[i].turnaround_time = time - p[i].arrival_time;\n            p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n            avg_waiting_time += p[i].waiting_time;\n            avg_turnaround_time += p[i].turnaround_time;\n            flag = 0;\n        }\n        if (i == n - 1) {\n            i = 0;\n        } else if (p[i + 1].arrival_time <= time) {\n            i++;\n        } else {\n            i = 0;\n        }\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 27,
        "slip_no": "slip 14",
        "question": "Write a C program to implement the shell which displays the command prompt “myshell$”. It accepts the command, tokenize the command line and execute it by creating the child process. Also implement the additional command ‘typeline’ as: typeline +n filename :- To print first n lines in the file.",
        "language": "c",
        "code": "#include<stdio.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<string.h>\n#include<stdlib.h>\n#include<fcntl.h>\nvoid typeline_n(int n, char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    char line[256];\n    int count = 0;\n    if (file == NULL) {\n        printf(\"Cannot open file %s\\n\", filename);\n        return;\n    }\n    while (fgets(line, sizeof(line), file) && count < n) {\n        printf(\"%s\", line);\n        count++;\n    }\n    fclose(file);\n}\nint main() {\n    char command[100];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, 100, stdin);\n        command[strlen(command) - 1] = '\\0'; // Remove newline\n        char *token = strtok(command, \" \");\n        if (strcmp(token, \"typeline\") == 0) {\n            token = strtok(NULL, \" \");\n            if (token[0] == '+') {\n                int n = atoi(token + 1);\n                token = strtok(NULL, \" \");\n                typeline_n(n, token);\n            }\n        } else if (fork() == 0) {\n            execlp(token, token, NULL);\n        } else {\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 28,
        "slip_no": "slip 14",
        "question": "Write a C program to simulate Non-preemptive Shortest Job First (SJF) scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include<stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time;\n};\nvoid sortByArrival(struct process p[], int n) {\n    struct process temp;\n    for(int i = 0; i < n - 1; i++) {\n        for(int j = i + 1; j < n; j++) {\n            if(p[i].arrival_time > p[j].arrival_time) {\n                temp = p[i];\n                p[i] = p[j];\n                p[j] = temp;\n            }\n        }\n    }\n}\nint main() {\n    int n, total = 0;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time and burst time for process P%d: \", i+1);\n        p[i].id = i + 1;\n        scanf(\"%d%d\", &p[i].arrival_time, &p[i].burst_time);\n    }\n    sortByArrival(p, n);\n    printf(\"\\nGantt Chart\\n\");\n    for(int i = 0; i < n; i++) {\n        if(total < p[i].arrival_time) {\n            total = p[i].arrival_time;\n        }\n        total += p[i].burst_time;\n        p[i].turnaround_time = total - p[i].arrival_time;\n        p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n        avg_waiting_time += p[i].waiting_time;\n        avg_turnaround_time += p[i].turnaround_time;\n        printf(\"| P%d \", p[i].id);\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 29,
        "slip_no": "slip 15",
        "question": "Write a C program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following ‘list’ commands as myshell$ list f dirname :- To print names of all the files in the current directory.",
        "language": "c",
        "code": "#include<stdio.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<string.h>\n#include<stdlib.h>\n#include<dirent.h>\nvoid list_files(char *dirname) {\n    struct dirent *de;\n    DIR *dr = opendir(dirname);\n    if (dr == NULL) {\n        printf(\"Could not open current directory\\n\");\n        return;\n    }\n    while ((de = readdir(dr)) != NULL) {\n        if (de->d_type == DT_REG) { // Regular file\n            printf(\"%s\\n\", de->d_name);\n        }\n    }\n    closedir(dr);\n}\nint main() {\n    char command[100];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, 100, stdin);\n        command[strlen(command) - 1] = '\\0'; // Remove newline\n        char *token = strtok(command, \" \");\n        if (strcmp(token, \"list\") == 0) {\n            token = strtok(NULL, \" \");\n            if (strcmp(token, \"f\") == 0) {\n                token = strtok(NULL, \" \");\n                list_files(token);\n            }\n        } else if (fork() == 0) {\n            execlp(token, token, NULL);\n        } else {\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 30,
        "slip_no": "slip 15",
        "question": "Write the program to simulate preemptive Shortest Job First (SJF) scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include<stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time, remaining_time;\n};\nint main() {\n    int n, time = 0, smallest, remain, finish_time, flag = 0;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    remain = n;\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time and burst time for process P%d: \", i + 1);\n        p[i].id = i + 1;\n        scanf(\"%d%d\", &p[i].arrival_time, &p[i].burst_time);\n        p[i].remaining_time = p[i].burst_time;\n    }\n    printf(\"\\nGantt Chart\\n\");\n    while (remain != 0) {\n        smallest = 9;\n        for (int i = 0; i < n; i++) {\n            if (p[i].arrival_time <= time && p[i].remaining_time > 0 && (smallest == 9 || p[i].remaining_time < p[smallest].remaining_time)) {\n                smallest = i;\n            }\n        }\n        if (smallest == 9) {\n            time++;\n            continue;\n        }\n        p[smallest].remaining_time--;\n        printf(\"| P%d \", p[smallest].id);\n        if (p[smallest].remaining_time == 0) {\n            remain--;\n            finish_time = time + 1;\n            p[smallest].turnaround_time = finish_time - p[smallest].arrival_time;\n            p[smallest].waiting_time = p[smallest].turnaround_time - p[smallest].burst_time;\n            avg_waiting_time += p[smallest].waiting_time;\n            avg_turnaround_time += p[smallest].turnaround_time;\n        }\n        time++;\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 31,
        "slip_no": "slip 16",
        "question": "Write a program to implement the toy shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. count c filename :- To print number of characters in the file. count w filename :- To print number of words in the file.",
        "language": "c",
        "code": "#include<stdio.h>\n#include<unistd.h>\n#include<sys/types.h>\n#include<string.h>\n#include<stdlib.h>\nvoid count_characters(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    char ch;\n    int count = 0;\n    if (file == NULL) {\n        printf(\"Cannot open file %s\\n\", filename);\n        return;\n    }\n    while ((ch = fgetc(file)) != EOF) {\n        count++;\n    }\n    printf(\"Number of characters: %d\\n\", count);\n    fclose(file);\n}\nvoid count_words(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    char word[50];\n    int count = 0;\n    if (file == NULL) {\n        printf(\"Cannot open file %s\\n\", filename);\n        return;\n    }\n    while (fscanf(file, \"%s\", word) != EOF) {\n        count++;\n    }\n    printf(\"Number of words: %d\\n\", count);\n    fclose(file);\n}\nint main() {\n    char command[100];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, 100, stdin);\n        command[strlen(command) - 1] = '\\0'; // Remove newline\n        char *token = strtok(command, \" \");\n        if (strcmp(token, \"count\") == 0) {\n            token = strtok(NULL, \" \");\n            if (strcmp(token, \"c\") == 0) {\n                token = strtok(NULL, \" \");\n                count_characters(token);\n            } else if (strcmp(token, \"w\") == 0) {\n                token = strtok(NULL, \" \");\n                count_words(token);\n            }\n        } else if (fork() == 0) {\n            execlp(token, token, NULL);\n        } else {\n            wait(NULL);\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 32,
        "slip_no": "slip 16",
        "question": "Write the program to simulate Non preemptive priority scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include<stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, priority, waiting_time, turnaround_time;\n};\nvoid sortByPriority(struct process p[], int n) {\n    struct process temp;\n    for(int i = 0; i < n - 1; i++) {\n        for(int j = i + 1; j < n; j++) {\n            if(p[i].priority > p[j].priority) {\n                temp = p[i];\n                p[i] = p[j];\n                p[j] = temp;\n            }\n        }\n    }\n}\nint main() {\n    int n, total = 0;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time, burst time, and priority for process P%d: \", i + 1);\n        p[i].id = i + 1;\n        scanf(\"%d%d%d\", &p[i].arrival_time, &p[i].burst_time, &p[i].priority);\n    }\n    sortByPriority(p, n);\n    printf(\"\\nGantt Chart\\n\");\n    for(int i = 0; i < n; i++) {\n        if(total < p[i].arrival_time) {\n            total = p[i].arrival_time;\n        }\n        total += p[i].burst_time;\n        p[i].turnaround_time = total - p[i].arrival_time;\n        p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n        avg_waiting_time += p[i].waiting_time;\n        avg_turnaround_time += p[i].turnaround_time;\n        printf(\"| P%d \", p[i].id);\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 33,
        "slip_no": "slip 17",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the Optimal page replacement algorithm. Assume the memory of n frames.",
        "language": "c",
        "code": "#include<stdio.h>\n#define MAX 20\nint find_farthest(int pages[], int frames[], int n, int pos) {\n    int farthest = -1, index = -1;\n    for (int i = 0; i < n; i++) {\n        int j;\n        for (j = pos; j < MAX; j++) {\n            if (frames[i] == pages[j]) {\n                if (j > farthest) {\n                    farthest = j;\n                    index = i;\n                }\n                break;\n            }\n        }\n        if (j == MAX) return i;\n    }\n    return index;\n}\nint main() {\n    int pages[MAX] = {7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6};\n    int frames[3], n = 3, page_faults = 0;\n    for (int i = 0; i < n; i++) frames[i] = -1;\n    for (int i = 0; i < MAX; i++) {\n        int flag = 0;\n        for (int j = 0; j < n; j++) {\n            if (frames[j] == pages[i]) {\n                flag = 1;\n                break;\n            }\n        }\n        if (!flag) {\n            page_faults++;\n            if (i < n) frames[i] = pages[i];\n            else frames[find_farthest(pages, frames, n, i)] = pages[i];\n        }\n        printf(\"\\nPage: %d\\t\", pages[i]);\n        for (int k = 0; k < n; k++) printf(\"%d \", frames[k]);\n    }\n    printf(\"\\nTotal Page Faults: %d\\n\", page_faults);\n    return 0;\n}"
    },
    {
        "id": 34,
        "slip_no": "slip 17",
        "question": "Write the program to simulate FCFS CPU-scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include<stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time;\n};\nint main() {\n    int n;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time and burst time for process P%d: \", i + 1);\n        p[i].id = i + 1;\n        scanf(\"%d%d\", &p[i].arrival_time, &p[i].burst_time);\n    }\n    printf(\"\\nGantt Chart\\n\");\n    int current_time = 0;\n    for (int i = 0; i < n; i++) {\n        if (current_time < p[i].arrival_time) current_time = p[i].arrival_time;\n        current_time += p[i].burst_time;\n        p[i].turnaround_time = current_time - p[i].arrival_time;\n        p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n        avg_waiting_time += p[i].waiting_time;\n        avg_turnaround_time += p[i].turnaround_time;\n        printf(\"| P%d \", p[i].id);\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 35,
        "slip_no": "slip 18",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the LRU page replacement algorithm. Assume the memory of n frames.",
        "language": "c",
        "code": "#include<stdio.h>\n#define MAX 20\nint find_lru(int time[], int n) {\n    int min = time[0], pos = 0;\n    for (int i = 1; i < n; i++) {\n        if (time[i] < min) {\n            min = time[i];\n            pos = i;\n        }\n    }\n    return pos;\n}\nint main() {\n    int pages[MAX] = {3, 4, 5, 6, 3, 4, 7, 3, 4, 5, 6, 7, 2, 4, 6};\n    int frames[3], time[3], n = 3, page_faults = 0, counter = 0;\n    for (int i = 0; i < n; i++) frames[i] = -1;\n    for (int i = 0; i < MAX; i++) {\n        int flag1 = 0, flag2 = 0;\n        for (int j = 0; j < n; j++) {\n            if (frames[j] == pages[i]) {\n                counter++;\n                time[j] = counter;\n                flag1 = flag2 = 1;\n                break;\n            }\n        }\n        if (!flag1) {\n            for (int j = 0; j < n; j++) {\n                if (frames[j] == -1) {\n                    counter++;\n                    frames[j] = pages[i];\n                    time[j] = counter;\n                    page_faults++;\n                    flag2 = 1;\n                    break;\n                }\n            }\n        }\n        if (!flag2) {\n            int pos = find_lru(time, n);\n            counter++;\n            frames[pos] = pages[i];\n            time[pos] = counter;\n            page_faults++;\n        }\n        printf(\"\\nPage: %d\\t\", pages[i]);\n        for (int k = 0; k < n; k++) printf(\"%d \", frames[k]);\n    }\n    printf(\"\\nTotal Page Faults: %d\\n\", page_faults);\n    return 0;\n}"
    },
    {
        "id": 36,
        "slip_no": "slip 18",
        "question": "Write a C program to simulate FCFS CPU-scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include<stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time;\n};\nint main() {\n    int n;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time and burst time for process P%d: \", i + 1);\n        p[i].id = i + 1;\n        scanf(\"%d%d\", &p[i].arrival_time, &p[i].burst_time);\n    }\n    printf(\"\\nGantt Chart\\n\");\n    int current_time = 0;\n    for (int i = 0; i < n; i++) {\n        if (current_time < p[i].arrival_time) current_time = p[i].arrival_time;\n        current_time += p[i].burst_time;\n        p[i].turnaround_time = current_time - p[i].arrival_time;\n        p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n        avg_waiting_time += p[i].waiting_time;\n        avg_turnaround_time += p[i].turnaround_time;\n        printf(\"| P%d \", p[i].id);\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 37,
        "slip_no": "slip 19",
        "question": "Write a C program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally, it should interpret the following ‘list’ commands as myshell$ list f dirname :- To print names of all the files in the current directory.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <dirent.h>\n#define MAX_INPUT_SIZE 1024\nint main() {\n    char input[MAX_INPUT_SIZE];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(input, sizeof(input), stdin);\n        input[strcspn(input, \"\\n\")] = 0;  // Remove newline character\n\n        char *command = strtok(input, \" \");\n        if (strcmp(command, \"list\") == 0) {\n            char *option = strtok(NULL, \" \");\n            char *dirname = strtok(NULL, \" \");\n            if (option && strcmp(option, \"f\") == 0 && dirname) {\n                DIR *dir = opendir(dirname);\n                if (dir == NULL) {\n                    perror(\"Could not open directory\");\n                } else {\n                    struct dirent *entry;\n                    while ((entry = readdir(dir)) != NULL) {\n                        printf(\"%s\\n\", entry->d_name);\n                    }\n                    closedir(dir);\n                }\n            }\n        } else if (strcmp(command, \"exit\") == 0) {\n            break;\n        } else {\n            pid_t pid = fork();\n            if (pid == 0) {\n                execlp(command, command, NULL);\n                perror(\"Command execution failed\");\n                exit(EXIT_FAILURE);\n            } else {\n                wait(NULL);\n            }\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 38,
        "slip_no": "slip 19",
        "question": "Write the simulation program for Round Robin scheduling for given time quantum. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time, and burst time. The output should give the Gantt chart, turnaround time, and waiting time for each process. Also display the average turnaround time and average waiting time.",
        "language": "c",
        "code": "#include <stdio.h>\n#define MAX 10\nint main() {\n    int n, burst_time[MAX], waiting_time[MAX], turnaround_time[MAX], arrival_time[MAX], i, j, time_quantum, remaining_time[MAX];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    printf(\"Enter arrival times and burst times: \\n\");\n    for (i = 0; i < n; i++) {\n        printf(\"Process P%d: \", i + 1);\n        scanf(\"%d %d\", &arrival_time[i], &burst_time[i]);\n        remaining_time[i] = burst_time[i];\n    }\n    printf(\"Enter time quantum: \");\n    scanf(\"%d\", &time_quantum);\n    int complete = 0, t = 0;\n    printf(\"\\nGantt Chart: \\n\");\n    while (complete < n) {\n        for (i = 0; i < n; i++) {\n            if (remaining_time[i] > 0 && arrival_time[i] <= t) {\n                if (remaining_time[i] > time_quantum) {\n                    t += time_quantum;\n                    remaining_time[i] -= time_quantum;\n                } else {\n                    t += remaining_time[i];\n                    waiting_time[i] = t - burst_time[i] - arrival_time[i];\n                    turnaround_time[i] = waiting_time[i] + burst_time[i];\n                    printf(\"P%d \", i + 1);\n                    remaining_time[i] = 0;\n                    complete++;\n                }\n            }\n        }\n    }\n    printf(\"\\n\");\n    for (i = 0; i < n; i++) {\n        avg_waiting_time += waiting_time[i];\n        avg_turnaround_time += turnaround_time[i];\n    }\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", i + 1, burst_time[i], waiting_time[i], turnaround_time[i]);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 39,
        "slip_no": "slip 20",
        "question": "Write a C program to implement the shell which displays the command prompt “myshell$”. It accepts the command, tokenizes the command line, and executes it by creating the child process. Also implement the additional command ‘typeline’ as typeline -a filename :- To print all lines in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#define MAX_INPUT_SIZE 1024\nint main() {\n    char input[MAX_INPUT_SIZE];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(input, sizeof(input), stdin);\n        input[strcspn(input, \"\\n\")] = 0;  // Remove newline character\n\n        char *command = strtok(input, \" \");\n        if (strcmp(command, \"typeline\") == 0) {\n            char *option = strtok(NULL, \" \");\n            char *filename = strtok(NULL, \" \");\n            if (option && strcmp(option, \"-a\") == 0 && filename) {\n                FILE *file = fopen(filename, \"r\");\n                if (file == NULL) {\n                    perror(\"Could not open file\");\n                } else {\n                    char line[256];\n                    while (fgets(line, sizeof(line), file)) {\n                        printf(\"%s\", line);\n                    }\n                    fclose(file);\n                }\n            }\n        } else if (strcmp(command, \"exit\") == 0) {\n            break;\n        } else {\n            pid_t pid = fork();\n            if (pid == 0) {\n                execlp(command, command, NULL);\n                perror(\"Command execution failed\");\n                exit(EXIT_FAILURE);\n            } else {\n                wait(NULL);\n            }\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 40,
        "slip_no": "slip 20",
        "question": "Write the program to simulate Non-preemptive Shortest Job First (SJF) – scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time, and burst time. The output should give Gantt chart, turnaround time, and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include <stdio.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time;\n};\nint main() {\n    int n;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time and burst time for process P%d: \", i + 1);\n        p[i].id = i + 1;\n        scanf(\"%d%d\", &p[i].arrival_time, &p[i].burst_time);\n    }\n    int current_time = 0;\n    int completed = 0;\n    int min_index;\n    printf(\"\\nGantt Chart\\n\");\n    while (completed < n) {\n        min_index = -1;\n        for (int i = 0; i < n; i++) {\n            if (p[i].arrival_time <= current_time && (min_index == -1 || p[i].burst_time < p[min_index].burst_time) && p[i].burst_time > 0) {\n                min_index = i;\n            }\n        }\n        if (min_index != -1) {\n            current_time += p[min_index].burst_time;\n            p[min_index].turnaround_time = current_time - p[min_index].arrival_time;\n            p[min_index].waiting_time = p[min_index].turnaround_time - p[min_index].burst_time;\n            avg_waiting_time += p[min_index].waiting_time;\n            avg_turnaround_time += p[min_index].turnaround_time;\n            printf(\"| P%d \", p[min_index].id);\n            p[min_index].burst_time = 0; // mark as completed\n            completed++;\n        } else {\n            current_time++; // no process is ready\n        }\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 41,
        "slip_no": "slip 21",
        "question": "Write a C Program to create a child process using fork (), display parent and child process id. Child process will display the message “I am Child Process” and the parent process should display “I am Parent Process”.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\nint main() {\n    pid_t pid = fork();\n    if (pid < 0) {\n        perror(\"Fork failed\");\n        return 1;\n    }\n    if (pid == 0) {\n        // Child process\n        printf(\"I am Child Process. My PID is %d.\\n\", getpid());\n    } else {\n        // Parent process\n        printf(\"I am Parent Process. My PID is %d. My Child's PID is %d.\\n\", getpid(), pid);\n    }\n    return 0;\n}"
    },
    {
        "id": 42,
        "slip_no": "slip 21",
        "question": "Write a C program to simulate Preemptive Priority scheduling. The arrival time and first CPU-burst and priority for different n number of processes should be input to the algorithm. Assume the fixed IO waiting time (2 units). The next CPU-burst should be generated randomly. The output should give Gantt chart, turnaround time, and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#define MAX 10\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time, priority;\n};\nvoid sort_processes(struct process p[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (p[i].priority > p[j].priority) {\n                struct process temp = p[i];\n                p[i] = p[j];\n                p[j] = temp;\n            }\n        }\n    }\n}\nint main() {\n    int n, current_time = 0, completed = 0;\n    struct process p[MAX];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    srand(time(NULL));\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time, burst time and priority for process P%d: \", i + 1);\n        scanf(\"%d %d %d\", &p[i].arrival_time, &p[i].burst_time, &p[i].priority);\n        p[i].id = i + 1;\n    }\n    printf(\"\\nGantt Chart: \\n\");\n    while (completed < n) {\n        sort_processes(p, n);\n        for (int i = 0; i < n; i++) {\n            if (p[i].arrival_time <= current_time && p[i].burst_time > 0) {\n                printf(\"P%d \", p[i].id);\n                current_time += p[i].burst_time + 2; // Add fixed IO waiting time\n                p[i].waiting_time = current_time - p[i].arrival_time - p[i].burst_time;\n                p[i].turnaround_time = p[i].waiting_time + p[i].burst_time;\n                avg_waiting_time += p[i].waiting_time;\n                avg_turnaround_time += p[i].turnaround_time;\n                p[i].burst_time = 0; // Mark as completed\n                completed++;\n                break;\n            }\n        }\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 43,
        "slip_no": "slip 22",
        "question": "Write a C program that demonstrates the use of nice() system call. After a child Process is started using fork (), assign higher priority to the child using nice() system call.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <sys/resource.h>\nint main() {\n    pid_t pid = fork();\n    if (pid < 0) {\n        perror(\"Fork failed\");\n        return 1;\n    }\n    if (pid == 0) {\n        // Child process\n        nice(10);  // Increase the priority of the child process\n        printf(\"Child Process: My PID is %d and my priority is now %d.\\n\", getpid(), getpriority(PRIO_PROCESS, getpid()));\n    } else {\n        // Parent process\n        printf(\"Parent Process: My PID is %d.\\n\", getpid());\n    }\n    return 0;\n}"
    },
    {
        "id": 44,
        "slip_no": "slip 22",
        "question": "Write a C program to simulate Non-preemptive priority scheduling. The arrival time and first CPU-burst of different jobs should be input to the system. Accept no. of Processes, arrival time and burst time. The output should give Gantt chart, turnaround time and waiting time for each process. Also find the average waiting time and turnaround time.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\nstruct process {\n    int id, arrival_time, burst_time, waiting_time, turnaround_time, priority;\n};\nvoid sort_processes(struct process p[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = i + 1; j < n; j++) {\n            if (p[i].priority > p[j].priority) {\n                struct process temp = p[i];\n                p[i] = p[j];\n                p[j] = temp;\n            }\n        }\n    }\n}\nint main() {\n    int n, current_time = 0, completed = 0;\n    struct process p[10];\n    float avg_waiting_time = 0, avg_turnaround_time = 0;\n    printf(\"Enter number of processes: \");\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter arrival time, burst time and priority for process P%d: \", i + 1);\n        scanf(\"%d %d %d\", &p[i].arrival_time, &p[i].burst_time, &p[i].priority);\n        p[i].id = i + 1;\n    }\n    printf(\"\\nGantt Chart\\n\");\n    while (completed < n) {\n        for (int i = 0; i < n; i++) {\n            if (p[i].arrival_time <= current_time && p[i].burst_time > 0) {\n                printf(\"| P%d \", p[i].id);\n                current_time += p[i].burst_time;\n                p[i].turnaround_time = current_time - p[i].arrival_time;\n                p[i].waiting_time = p[i].turnaround_time - p[i].burst_time;\n                avg_waiting_time += p[i].waiting_time;\n                avg_turnaround_time += p[i].turnaround_time;\n                p[i].burst_time = 0; // Mark as completed\n                completed++;\n                break;\n            }\n        }\n    }\n    printf(\"|\\n\");\n    printf(\"\\nProcess\\tBurst Time\\tWaiting Time\\tTurnaround Time\\n\");\n    for (int i = 0; i < n; i++) {\n        printf(\"P%d\\t%d\\t\\t%d\\t\\t%d\\n\", p[i].id, p[i].burst_time, p[i].waiting_time, p[i].turnaround_time);\n    }\n    printf(\"\\nAverage Waiting Time: %.2f\\n\", avg_waiting_time / n);\n    printf(\"Average Turnaround Time: %.2f\\n\", avg_turnaround_time / n);\n    return 0;\n}"
    },
    {
        "id": 45,
        "slip_no": "slip 23",
        "question": "Write a C program to illustrate the concept of orphan process. Parent process creates a child and terminates before child has finished its task. So child process becomes orphan process. (Use fork(), sleep(), getpid(), getppid()).",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\nint main() {\n    pid_t pid = fork();\n\n    if (pid < 0) {\n        perror(\"Fork failed\");\n        return 1;\n    }\n\n    if (pid == 0) {\n        // Child process\n        sleep(5); // Simulate work by sleeping\n        printf(\"Child Process: My PID is %d and my Parent PID is %d.\\n\", getpid(), getppid());\n    } else {\n        // Parent process\n        printf(\"Parent Process: My PID is %d. Terminating now.\\n\", getpid());\n        exit(0); // Terminate parent process\n    }\n    return 0;\n}"
    },
    {
        "id": 46,
        "slip_no": "slip 23",
        "question": "Write the simulation program for demand paging and show the page scheduling and total number of page faults according to the Optimal page replacement algorithm. Assume the memory of n frames. Reference String : 7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#define MAX_FRAMES 10\n#define REF_STRING_LENGTH 14\n\nint findOptimal(int pages[], int currentIndex, int frames[], int nFrames) {\n    int farthest = currentIndex;\n    int pageIndex = -1;\n\n    for (int i = 0; i < nFrames; i++) {\n        int j;\n        for (j = currentIndex; j < REF_STRING_LENGTH; j++) {\n            if (frames[i] == pages[j]) {\n                if (j > farthest) {\n                    farthest = j;\n                    pageIndex = i;\n                }\n                break;\n            }\n        }\n        if (j == REF_STRING_LENGTH) {\n            return i; // Page not found in reference string\n        }\n    }\n    return pageIndex;\n}\n\nint main() {\n    int pages[REF_STRING_LENGTH] = {7, 5, 4, 8, 5, 7, 2, 3, 1, 3, 5, 9, 4, 6};\n    int frames[MAX_FRAMES];\n    int nFrames, pageFaults = 0;\n    printf(\"Enter number of frames: \");\n    scanf(\"%d\", &nFrames);\n\n    for (int i = 0; i < nFrames; i++) {\n        frames[i] = -1; // Initialize frames\n    }\n\n    for (int i = 0; i < REF_STRING_LENGTH; i++) {\n        int j;\n        for (j = 0; j < nFrames; j++) {\n            if (frames[j] == pages[i]) {\n                break; // Page is already in a frame\n            }\n        }\n\n        if (j == nFrames) {\n            // Page fault\n            pageFaults++;\n            int pageIndex = findOptimal(pages, i, frames, nFrames);\n            frames[pageIndex] = pages[i]; // Replace the optimal page\n            printf(\"Page fault: %d - Loaded page %d\\n\", pageFaults, pages[i]);\n        } else {\n            printf(\"Page hit: %d - Page %d already loaded\\n\", i + 1, pages[i]);\n        }\n    }\n\n    printf(\"Total Page Faults: %d\\n\", pageFaults);\n    return 0;\n}"
    },
    {
        "id": 47,
        "slip_no": "slip 24",
        "question": "Write a C program to accept n integers to be sorted. Main function creates child process using fork system call. Parent process sorts the integers using bubble sort and waits for child process using wait system call. Child process sorts the integers using insertion sort.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nvoid insertionSort(int arr[], int n) {\n    for (int i = 1; i < n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n        arr[j + 1] = key;\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Enter number of integers: \");\n    scanf(\"%d\", &n);\n    int arr[n];\n    printf(\"Enter %d integers: \", n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    pid_t pid = fork();\n    if (pid < 0) {\n        perror(\"Fork failed\");\n        return 1;\n    }\n\n    if (pid == 0) {\n        // Child process\n        insertionSort(arr, n);\n        printf(\"Child Process (Insertion Sort): Sorted array: \");\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", arr[i]);\n        }\n        printf(\"\\n\");\n        exit(0);\n    } else {\n        // Parent process\n        wait(NULL); // Wait for child process to finish\n        bubbleSort(arr, n);\n        printf(\"Parent Process (Bubble Sort): Sorted array: \");\n        for (int i = 0; i < n; i++) {\n            printf(\"%d \", arr[i]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
    },
    {
        "id": 48,
        "slip_no": "slip 24",
        "question": "Write a C program to implement the toy shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. count c filename :- To print number of characters in the file. count w filename :- To print number of words in the file. count l filename :- To print number of lines in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nvoid countCharacters(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"File not found\");\n        return;\n    }\n    fseek(file, 0, SEEK_END);\n    printf(\"Number of characters: %ld\\n\", ftell(file));\n    fclose(file);\n}\n\nvoid countWords(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"File not found\");\n        return;\n    }\n    int count = 0;\n    char word[100];\n    while (fscanf(file, \"%s\", word) != EOF) {\n        count++;\n    }\n    printf(\"Number of words: %d\\n\", count);\n    fclose(file);\n}\n\nvoid countLines(char *filename) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"File not found\");\n        return;\n    }\n    int count = 0;\n    char ch;\n    while ((ch = fgetc(file)) != EOF) {\n        if (ch == '\\n') {\n            count++;\n        }\n    }\n    printf(\"Number of lines: %d\\n\", count);\n    fclose(file);\n}\n\nint main() {\n    char command[256];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, sizeof(command), stdin);\n        command[strcspn(command, \"\\n\")] = '\\0'; // Remove newline character\n\n        char *token = strtok(command, \" \");\n        if (token == NULL) continue;\n\n        if (strcmp(token, \"count\") == 0) {\n            token = strtok(NULL, \" \");\n            if (token == NULL) continue;\n            char *filename = strtok(NULL, \" \");\n            if (filename == NULL) continue;\n\n            pid_t pid = fork();\n            if (pid < 0) {\n                perror(\"Fork failed\");\n                continue;\n            }\n            if (pid == 0) {\n                // Child process\n                if (strcmp(token, \"c\") == 0) {\n                    countCharacters(filename);\n                } else if (strcmp(token, \"w\") == 0) {\n                    countWords(filename);\n                } else if (strcmp(token, \"l\") == 0) {\n                    countLines(filename);\n                } else {\n                    printf(\"Invalid command\\n\");\n                }\n                exit(0);\n            } else {\n                wait(NULL); // Wait for child process to finish\n            }\n        } else {\n            printf(\"Invalid command\\n\");\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 49,
        "slip_no": "slip 25",
        "question": "Write a C program that accepts an integer array. Main function forks child process. Parent process sorts an integer array and passes the sorted array to child process through the command line arguments of execve() system call. The child process uses execve() system call to load new program that uses this sorted array for performing the binary search to search the particular item in the array.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <string.h>\n\nvoid bubbleSort(int arr[], int n) {\n    for (int i = 0; i < n - 1; i++) {\n        for (int j = 0; j < n - i - 1; j++) {\n            if (arr[j] > arr[j + 1]) {\n                int temp = arr[j];\n                arr[j] = arr[j + 1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n\nint main() {\n    int n;\n    printf(\"Enter number of integers: \");\n    scanf(\"%d\", &n);\n    int arr[n];\n    printf(\"Enter %d integers: \", n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d\", &arr[i]);\n    }\n\n    bubbleSort(arr, n);\n\n    char *args[n + 2]; // Arguments for execve\n    args[0] = \"./binary_search\"; // Name of the new program\n    for (int i = 0; i < n; i++) {\n        args[i + 1] = malloc(10 * sizeof(char));\n        sprintf(args[i + 1], \"%d\", arr[i]); // Convert integers to strings\n    }\n    args[n + 1] = NULL;\n\n    pid_t pid = fork();\n    if (pid < 0) {\n        perror(\"Fork failed\");\n        return 1;\n    }\n\n    if (pid == 0) {\n        // Child process\n        execve(\"./binary_search\", args, NULL);\n        perror(\"execve failed\"); // Only reached if execve fails\n        exit(1);\n    } else {\n        // Parent process\n        wait(NULL); // Wait for child process\n        for (int i = 1; i <= n; i++) {\n            free(args[i]); // Free allocated memory\n        }\n    }\n    return 0;\n}"
    },
    {
        "id": 50,
        "slip_no": "slip 25",
        "question": "Write a program to implement the shell. It should display the command prompt “myshell$”. Tokenize the command line and execute the given command by creating the child process. Additionally it should interpret the following commands. myshell$ search f filename pattern :- To display first occurrence of pattern in the file.",
        "language": "c",
        "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n\nvoid searchPattern(char *filename, char *pattern) {\n    FILE *file = fopen(filename, \"r\");\n    if (file == NULL) {\n        perror(\"File not found\");\n        return;\n    }\n    char line[256];\n    int lineNumber = 0;\n    while (fgets(line, sizeof(line), file)) {\n        lineNumber++;\n        if (strstr(line, pattern)) {\n            printf(\"Pattern found in %s at line %d: %s\", filename, lineNumber, line);\n            fclose(file);\n            return;\n        }\n    }\n    printf(\"Pattern not found in %s.\\n\", filename);\n    fclose(file);\n}\n\nint main() {\n    char command[256];\n    while (1) {\n        printf(\"myshell$ \");\n        fgets(command, sizeof(command), stdin);\n        command[strcspn(command, \"\\n\")] = 0; // Remove newline character\n\n        char *args[4];\n        char *token = strtok(command, \" \");\n        int i = 0;\n\n        while (token != NULL && i < 3) {\n            args[i++] = token;\n            token = strtok(NULL, \" \");\n        }\n        args[i] = NULL;\n\n        if (strcmp(args[0], \"search\") == 0 && strcmp(args[1], \"f\") == 0 && i == 3) {\n            pid_t pid = fork();\n            if (pid < 0) {\n                perror(\"Fork failed\");\n            } else if (pid == 0) {\n                searchPattern(args[2], args[3]);\n                exit(0);\n            } else {\n                wait(NULL);\n            }\n        } else {\n            printf(\"Invalid command.\\n\");\n        }\n    }\n    return 0;\n}"
    }
]